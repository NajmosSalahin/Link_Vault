<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>LinkVault - Enhanced Bookmark Manager</title>
<link href="https://fonts.googleapis.com" rel="preconnect"/>
<link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect"/>
<link href="https://fonts.googleapis.com/css2?family=Yuji+Syuku&family=Sawarabi+Mincho&display=swap" rel="stylesheet"/>
<style>
      *{margin:0;padding:0;box-sizing:border-box;}
      body{font-family:'Segoe UI', sans-serif;background:linear-gradient(135deg,#f4f4f4 0%,#e0e0e0 50%,#dcdcdc 100%);min-height:100vh;padding:20px;overflow-x:hidden;color:#333;position:relative;transition: background 0.3s, color 0.3s;}
      .header{text-align:center;margin-bottom:30px;position:relative;z-index:10;}
      .header h1{font-family:'Segoe UI', sans-serif;color:#2c3e50;font-size:3.5rem;font-weight:600;text-shadow:2px 2px 4px rgba(44,62,80,0.3);position:relative;}
      .header p{color:#34495e;font-size:1.2rem;font-style:italic;margin-top:10px;}
      .container{max-width:1400px;margin:0 auto;position:relative;z-index:10;}
      .controls-bar { display: flex; flex-wrap: wrap; gap: 10px; justify-content: space-between; align-items: center; margin-bottom: 20px; padding: 10px; background: rgba(255,255,255,0.7); border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.05); }
      .controls-bar input[type="text"], .controls-bar select { padding:10px 16px;border-radius:12px;border:2px solid rgba(212,102,155,0.4);background:rgba(255,255,255,0.75);backdrop-filter:blur(8px);font-family:'Sawarabi Mincho', serif;color:#d4669b;font-size:0.95rem; flex: 1; min-width: 150px;}
      .controls-bar .btn-group { display: flex; gap: 8px; flex-wrap: wrap;}
      .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(140px,1fr));gap:24px;}
      .link-box{background:rgba(255,255,255,0.95);backdrop-filter:blur(12px);-webkit-backdrop-filter:blur(12px);border-radius:16px;padding:24px;height:160px;display:flex;flex-direction:column;align-items:center;justify-content:center;cursor:pointer;border:2px solid rgba(100,100,100,0.3);box-shadow:0 8px 25px rgba(44,62,80,0.1);position:relative;overflow:hidden;opacity: 1;transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease, background-color 0.3s ease;}
      .link-box:hover{transform:translateY(-12px) scale(1.05);box-shadow:0 15px 35px rgba(44,62,80,0.25);border-color:rgba(100,100,100,0.6);background:rgba(255,255,255,0.85);}
      .link-box.empty{border:2px dashed rgba(44,62,80,0.4);color:#34495e;background:rgba(255,240,250,0.6);}
      .link-box.empty:hover{border-color:#2c3e50;color:#2c3e50;background:rgba(255,240,250,0.9);}
      .link-content{text-align:center;width:100%;display:flex;flex-direction:column;align-items:center;justify-content:center;height:100%;}
      .link-logo{width:36px;height:36px;border-radius:12px;margin-bottom:8px;object-fit:cover;box-shadow:0 4px 12px rgba(44,62,80,0.2);border:2px solid rgba(255,255,255,0.8);}
      .link-title{font-size:1rem;font-weight:600;color:#2c3e50;margin-bottom:2px;line-height:1.3;word-break:break-word;max-height:2.6em;overflow:hidden;}
      .link-url{font-size:0.85rem;color:#34495e;opacity:0.9;word-break:break-all;max-height:1.4em;overflow:hidden;}
      .add-icon{font-size:2.5rem;color:rgba(44,62,80,0.6);margin-bottom:8px; transition: transform 0.3s ease, color 0.3s ease;}
      .link-box.empty:hover .add-icon{color:#2c3e50;transform:scale(1.1) rotate(90deg);}
      .link-box.empty div:last-of-type{font-size:0.8rem;font-weight:600;}
      .modal{display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(44,62,80,0.3);backdrop-filter:blur(8px);z-index:1000;}
      .modal.show{display:flex;align-items:center;justify-content:center;}
      .modal-content{background:rgba(255,255,255,0.9);backdrop-filter:blur(15px);-webkit-backdrop-filter:blur(15px);padding:35px;border-radius:20px;border:2px solid rgba(100,100,100,0.5);width:90%;max-width:480px;box-shadow:0 15px 40px rgba(44,62,80,0.2);position:relative; transition: background-color 0.3s ease;}
      .modal h2{margin-bottom:25px;color:#2c3e50;font-family:'Segoe UI', sans-serif;font-size:1.8rem;font-weight:500;text-align:center;}
      .form-group{margin-bottom:20px;}
      .form-group label{display:block;margin-bottom:8px;color:#34495e;font-weight:600;font-size:0.9rem;}
      .form-group input{width:100%;padding:12px 16px;border:2px solid rgba(44,62,80,0.3);background:rgba(255,255,255,0.7);border-radius:12px;font-size:0.95rem;font-family:'Segoe UI', sans-serif;color:#2c3e50; transition: background-color 0.3s ease, border-color 0.3s ease;}
      .form-group input:focus{outline:none;border-color:#2c3e50;box-shadow:0 0 0 4px rgba(44,62,80,0.2);background:rgba(255,255,255,0.9);}
      .form-buttons{display:flex;gap:12px;justify-content:flex-end;margin-top:10px;}
      .btn{padding:10px 18px;border:none;border-radius:12px;font-size:0.85rem;font-weight:600;cursor:pointer;position:relative;overflow:hidden; transition: transform 0.2s ease, box-shadow 0.2s ease, background-color 0.2s ease, color 0.2s ease;}
      .btn:hover{transform:translateY(-3px);box-shadow:0 8px 20px rgba(0,0,0,0.15);}
      .btn-primary{background:linear-gradient(135deg,#2c3e50,#ff99cc);color:white;border:2px solid rgba(255,255,255,0.3);}
      .btn-primary:hover{background:linear-gradient(135deg,#c55590,#ff80b3);}
      .btn-secondary{background:rgba(255,240,250,0.8);color:#34495e;border:2px solid rgba(44,62,80,0.3);}
      .btn-secondary:hover{background:rgba(255,240,250,1);border-color:#2c3e50;}
      .btn-danger{background:linear-gradient(135deg,#ff8fab,#ff6b94);color:white;border:2px solid rgba(255,255,255,0.3);}
      .btn-danger:hover{background:linear-gradient(135deg,#ff7a9a,#ff5983);}
      .delete-btn{position:absolute;top:8px;right:8px;background:linear-gradient(135deg,#ff8fab,#ff6b94);color:white;border:2px solid rgba(255,255,255,0.7);border-radius:50%;width:26px;height:26px;cursor:pointer;font-size:0.9rem;display:flex;align-items:center;justify-content:center;box-shadow:0 4px 12px rgba(255,107,148,0.3);opacity:0;transform:scale(0.8); transition: opacity 0.2s ease, transform 0.2s ease;}
      .link-box:hover .delete-btn{opacity:1;transform:scale(1);}
      .delete-btn:hover{background:linear-gradient(135deg,#ff7a9a,#ff5983);transform:scale(1.1)!important;}
      @media (max-width:768px){ .grid{grid-template-columns:repeat(auto-fill,minmax(120px,1fr));gap:16px;} .header h1{font-size:2.5rem;} .header p{font-size:1rem;} .controls-bar{flex-direction: column; align-items: stretch;} .controls-bar input[type="text"],.controls-bar select,.controls-bar .btn-group {width: 100%;} .controls-bar .btn-group button { flex-grow: 1;} }
      @media (max-width: 600px) { /* #suggestionBox { display: none; } */ }
      body.dark { background:linear-gradient(135deg,#3a3a3a 0%,#2c2c2c 50%,#1e1e1e 100%); color: #e0e0e0; }
      body.dark .header h1 { color: #e0e0e0; text-shadow:2px 2px 4px rgba(0,0,0,0.5); }
      body.dark .header p { color: #b0b0b0; }
      body.dark .controls-bar { background: rgba(45,45,45,0.7); }
      body.dark .controls-bar input[type="text"], body.dark .controls-bar select { border-color: rgba(180,180,180,0.5); background: rgba(50,50,50,0.75); color: #ffcce6; }
      body.dark .link-box { background: rgba(30,30,30,0.85); border-color: rgba(150,150,150,0.4); box-shadow:0 8px 25px rgba(0,0,0,0.3); }
      body.dark .link-box:hover { background: rgba(45,45,45,0.95); border-color: rgba(180,180,180,0.7); }
      body.dark .link-box.empty { background: rgba(40,35,40,0.7); border-color: rgba(100,100,100,0.5); color: #9e9e9e; }
      body.dark .link-box.empty:hover { background: rgba(50,45,50,0.9); border-color: #b0b0b0; color: #e0e0e0; }
      body.dark .link-title { color: #e0e0e0; }
      body.dark .link-url { color: #a0a0a0; }
      body.dark .link-logo { border-color: rgba(50,50,50,0.8); }
      body.dark .add-icon { color:rgba(180,180,180,0.6); }
      body.dark .link-box.empty:hover .add-icon { color:#e0e0e0; }
      body.dark .modal-content { background:rgba(42,42,42,0.9); border-color: rgba(120,120,120,0.6); }
      body.dark .modal h2 { color: #e0e0e0; }
      body.dark .form-group label { color: #b0b0b0; }
      body.dark .form-group input { background:rgba(50,50,50,0.7); border-color: rgba(100,100,100,0.4); color: #e0e0e0; }
      body.dark .form-group input:focus { border-color: #ff99cc; box-shadow:0 0 0 4px rgba(255,153,204,0.25); background:rgba(55,55,55,0.9); }
      body.dark .btn-secondary { background:rgba(60,60,60,0.8); color: #d0d0d0; border-color: rgba(100,100,100,0.5); }
      body.dark .btn-secondary:hover { background:rgba(70,70,70,1); border-color: #e0e0e0; }
      body.dark #searchInput { border-color: rgba(212,102,155,0.6); background: rgba(40,40,40,0.75); color: #ffcce6; }
      body.dark label[for="darkModeToggle"], body.dark .darkModeLabelClass { color: #e0e0e0; }
      .tag-pill { display: inline-block; background: rgba(44,62,80,0.1); color: #2c3e50; border: 1px solid rgba(44,62,80,0.4); padding: 2px 8px; border-radius: 12px; font-size: 0.7rem; margin: 2px; }
      body.dark .tag-pill { background: rgba(180,180,180,0.15); color: #c0c0c0; border-color: rgba(180,180,180,0.4); }
      .click-count { font-size: 0.65rem; color: #34495e; margin-left: 5px; opacity: 0.7; }
      body.dark .click-count { color: #a0a0a0; }

      /* Notification Bar Styles */
      .notification-bar {
        position: fixed;
        bottom: 20px; /* Changed from top to bottom */
        left: 50%;
        transform: translateX(-50%);
        background-color: #2c3e50;
        color: white;
        padding: 12px 25px;
        border-radius: 10px;
        box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        z-index: 2000;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.5s ease, visibility 0.5s ease, transform 0.5s ease; /* Added transform for smoother appearance */
        font-size: 0.9rem;
      }
      .notification-bar.show {
        opacity: 1;
        visibility: visible;
        transform: translateX(-50%) translateY(0); /* Adjust Y for smooth slide-in from bottom */
      }
      body.dark .notification-bar {
        background-color: #ff99cc; /* A lighter, distinct color for dark mode */
        color: #2c3e50; /* Dark text for contrast on light background */
      }

</style>
</head>
<body>
<div class="header">
  <h1>LinkVault</h1> <p>Your Enhanced Bookmark Sanctuary</p>
</div>

<div class="container">
  <div class="controls-bar">
    <input id="searchInput" placeholder="🔍 Search links..." type="text"/>
    <div class="btn-group">
        <select id="sortOptions" class="btn btn-secondary" style="padding-right: 30px;"> <option value="default">Sort by...</option>
            <option value="name_asc">Name (A-Z)</option>
            <option value="name_desc">Name (Z-A)</option>
            <option value="date_asc">Date (Oldest)</option>
            <option value="date_desc">Date (Newest)</option>
        </select>
        <button class="btn btn-secondary" id="removeDuplicatesBtn">🗑️ Deduplicate</button>
        <button class="btn btn-danger" id="removeAllBtn">💥 Remove All</button>
    </div>
    <div class="btn-group"> <button class="btn btn-secondary" id="exportBtn">⬇️ Export JSON</button>
        <input accept=".json" id="importInput" style="display:none;" type="file"/>
        <button class="btn btn-secondary" id="importBtn">⬆️ Import JSON</button>
        <button class="btn btn-secondary" id="exportHtmlBtn">📤 Export HTML</button>
        <input accept=".html" id="importHtmlInput" style="display:none;" type="file"/>
        <button class="btn btn-secondary" id="importHtmlBtn">📁 Import HTML</button>
        <label for="darkModeToggle" class="btn btn-secondary" style="display:flex;align-items:center;gap:5px; cursor:pointer; padding: 10px 15px;">
            <input id="darkModeToggle" type="checkbox" style="margin-right: 5px;"/>🌙
        </label>
    </div>
  </div>

  <div class="grid" id="linkGrid">
    </div>
</div>

<div class="modal" id="linkModal">
  <div class="modal-content">
    <h2 id="modalTitle">Add New Link</h2>
    <form id="linkForm">
      <div class="form-group">
        <label for="linkUrl">🔗 Website URL</label>
        <input id="linkUrl" placeholder="example.com or any text" required="" type="text"/>
      </div>
      <div class="form-group">
        <label for="linkTitle">📝 Custom Title (optional)</label>
        <input id="linkTitle" placeholder="Leave empty to auto-fetch" type="text"/>
      </div>
      <div class="form-buttons">
        <button class="btn btn-secondary" id="cancelBtn" type="button">Cancel</button>
        <button class="btn btn-danger" id="modalDeleteBtn" style="display: none;" type="button">Delete</button> <button class="btn btn-primary" id="saveBtn" type="submit">Save Link</button>
      </div>
    </form>
  </div>
</div>

<div class="notification-bar" id="notificationBar">Notification Message</div>

<script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
<script>
  // Global instance of LinkManager
  let globalLinkManager = null;

  // --- Notification Function ---
  function showNotification(message, duration = 3000) {
    const notificationBar = document.getElementById('notificationBar');
    if (!notificationBar) {
        console.warn('Notification bar element not found.');
        // Fallback to console if element is missing, to avoid breaking user flow.
        // Do NOT use alert() here.
        console.log(`Notification: ${message}`);
        return;
    }
    notificationBar.textContent = message;
    notificationBar.classList.add('show');
    setTimeout(() => {
        notificationBar.classList.remove('show');
    }, duration);
  }


  class LinkManager {
    constructor() {
      this.links = this.loadLinks();
      this.currentEditIndex = null;
      this.totalBoxes = Math.max(5, Object.keys(this.links).length + 1);
      this.DEFAULT_FAVICON = "https://img.icons8.com/fluency/48/bookmark.png"; // Default icon
      this.init();
    }

    init() {
      this.createGrid();
      this.setupEventListeners();
      this.renderLinks();
    }

    createGrid() {
      const grid = document.getElementById('linkGrid');
      grid.innerHTML = ''; // Clear existing grid
      for (let i = 0; i < this.totalBoxes; i++) {
        const linkBox = document.createElement('div');
        linkBox.dataset.index = i;
        linkBox.className = 'link-box'; // Base class
        grid.appendChild(linkBox);
      }
    }

    setupEventListeners() {
      document.getElementById('linkForm').addEventListener('submit', (e) => {
        e.preventDefault();
        this.saveLink();
      });
      document.getElementById('cancelBtn').addEventListener('click', () => {
        this.closeModal();
      });
      // Ensure the delete button in the modal is correctly selected
      const modalDeleteBtn = document.getElementById('modalDeleteBtn'); // Corrected ID
      if (modalDeleteBtn) {
        modalDeleteBtn.addEventListener('click', () => {
          if (this.currentEditIndex !== null) {
            this.deleteLink(this.currentEditIndex);
            this.closeModal();
            showNotification('Bookmark deleted.', 2000);
          }
        });
      }
      document.getElementById('linkModal').addEventListener('click', (e) => {
        if (e.target.id === 'linkModal') {
          this.closeModal();
        }
      });

      // Event listeners for new features
      document.getElementById('removeDuplicatesBtn').addEventListener('click', () => {
        this.removeDuplicateLinks();
      });
      document.getElementById('removeAllBtn').addEventListener('click', () => {
        // Simple confirmation before destructive action
        // Using a custom modal for confirm is ideal, but for now, a direct action
        // or a less obtrusive confirm is needed. Since we can't use window.confirm:
        // For now, let's proceed with the action and show a notification.
        // A proper confirmation modal would be a good enhancement.
        const confirmed = true; // Placeholder for a future custom confirm dialog
        if (confirmed) {
            this.removeAllLinks();
        }
      });
      document.getElementById('sortOptions').addEventListener('change', (e) => {
        this.sortLinks(e.target.value);
      });
    }

    openModal(index) {
      this.currentEditIndex = index;
      const modal = document.getElementById('linkModal');
      const modalTitle = document.getElementById('modalTitle');
      const modalScopedDeleteBtn = document.getElementById('modalDeleteBtn'); // Corrected ID
      const urlInput = document.getElementById('linkUrl');
      const titleInput = document.getElementById('linkTitle');

      if (this.links[index]) {
        modalTitle.textContent = 'Edit Link';
        if(modalScopedDeleteBtn) modalScopedDeleteBtn.style.display = 'inline-block';
        urlInput.value = this.links[index].url;
        titleInput.value = this.links[index].customTitle || this.links[index].title || '';
      } else {
        modalTitle.textContent = 'Add New Link';
        if(modalScopedDeleteBtn) modalScopedDeleteBtn.style.display = 'none';
        urlInput.value = '';
        titleInput.value = '';
      }
      modal.classList.add('show');
      urlInput.focus();
    }

    closeModal() {
      const modal = document.getElementById('linkModal');
      modal.classList.remove('show');
      this.currentEditIndex = null;
      document.getElementById('linkForm').reset();
    }

    getHostname(url) {
        try {
            let parseableUrl = url;
            if (url && typeof url === 'string' && !url.startsWith('http://') && !url.startsWith('https://') && url.includes('.') && !url.includes(' ')) {
                parseableUrl = 'https://' + url;
            }
            return new URL(parseableUrl).hostname;
        } catch (e) {
            return null; 
        }
    }

    async fetchLinkData(url, customTitle) {
      let fetchedTitle = customTitle || '';
      let favicon = this.DEFAULT_FAVICON;
      let description = '';
      const domain = this.getHostname(url); 

      if (domain) { 
        try {
            // Using a CORS proxy for microlink to avoid potential direct fetch issues in some environments
            const microlinkApiUrl = `https://api.microlink.io/?url=${encodeURIComponent(url)}&meta=true&palette=false&audio=false&video=false&screenshot=false`;
            const res = await fetch(microlinkApiUrl);
            if (res.ok) {
                const json = await res.json();
                if (json.status === 'success' && json.data) {
                    const data = json.data;
                    if (!fetchedTitle && data.title) fetchedTitle = data.title;
                    description = data.description || '';
                    if (data.logo && data.logo.url && (data.logo.url.startsWith('http') || data.logo.url.startsWith('data:'))) {
                        favicon = data.logo.url;
                    } else if (data.image && data.image.url && (data.image.url.startsWith('http') || data.image.url.startsWith('data:'))) {
                        favicon = data.image.url; // Fallback to general image if logo specific one is not good
                    }
                }
            }
        } catch (e) {
            console.warn(`Microlink API request failed for ${url}:`, e);
        }
      }

      // Fallback for favicon if Microlink fails or doesn't provide one
      if (favicon === this.DEFAULT_FAVICON && domain) {
        const googleFaviconUrl = `https://www.google.com/s2/favicons?domain=${domain}&sz=128`;
        // Simple check: try to load it in an Image object to see if it's a valid image
        // This is a common pattern but can be unreliable. A HEAD request is better.
        try {
            const faviconRes = await fetch(googleFaviconUrl, { method: 'HEAD' }); // More reliable check
            if (faviconRes.ok) {
                const contentType = faviconRes.headers.get('content-type');
                // Check if content type is an image and not the default Google icon page
                if (contentType && contentType.startsWith('image/') && !faviconRes.url.includes('google.com/images/icons')) {
                    favicon = googleFaviconUrl;
                }
            }
        } catch (e) {
            console.warn(`Google Favicon service check failed for ${domain}:`, e);
        }
      }
      
      if (!fetchedTitle) { // If still no title
        if (domain) { 
            fetchedTitle = domain; // Use domain as title
        } else { // Otherwise, use the original input (url might be just text here)
            fetchedTitle = url.length > 30 ? url.substring(0, 27) + "..." : url;
        }
      }
      if (!fetchedTitle && url === "") fetchedTitle = "Untitled Bookmark";


      return {
        url: url, 
        title: fetchedTitle,
        customTitle: customTitle,
        favicon: favicon,
        description: description
        // addDate will be handled in saveLink
      };
    }

    async saveLink() {
      const urlInput = document.getElementById('linkUrl');
      let urlValue = urlInput.value.trim(); 
      const customTitle = document.getElementById('linkTitle').value.trim();
      const saveBtn = document.getElementById('saveBtn');
      const originalSaveBtnText = saveBtn.textContent;

      saveBtn.textContent = 'Saving...';
      saveBtn.disabled = true;

      let processedUrl = urlValue; 

      try {
        const potentialHostname = this.getHostname(urlValue); 
        if (potentialHostname && !urlValue.startsWith('http://') && !urlValue.startsWith('https://')) {
          processedUrl = 'https://' + urlValue;
        }
        
        const linkData = await this.fetchLinkData(processedUrl, customTitle);
        linkData.url = processedUrl; // Ensure the URL stored is the processed one

        // Handle addDate
        if (this.links[this.currentEditIndex] && this.links[this.currentEditIndex].addDate) {
            linkData.addDate = this.links[this.currentEditIndex].addDate; // Preserve existing addDate on edit
        } else {
            linkData.addDate = Date.now(); // Set new addDate for new links
        }
        linkData.lastModified = Date.now(); // Always update last modified

        this.links[this.currentEditIndex] = linkData;
        this.saveLinks();
        this.expandGridIfNeeded();
        this.renderLinks();
        this.closeModal();
        showNotification(this.links[this.currentEditIndex] ? 'Bookmark updated!' : 'Bookmark added!', 2000);
      } catch (error) {
        console.error('Error in saveLink process, falling back to basic data:', error);
        let fallbackUrl = urlValue;
        const potentialHostnameForFallback = this.getHostname(urlValue);
        if (potentialHostnameForFallback && !urlValue.startsWith('http://') && !urlValue.startsWith('https://')) {
          fallbackUrl = 'https://' + urlValue;
        }

        let fallbackTitle = customTitle;
        if (!fallbackTitle) {
            fallbackTitle = potentialHostnameForFallback || (fallbackUrl.startsWith('http') ? fallbackUrl : 'Untitled Bookmark');
             if (fallbackTitle === fallbackUrl && potentialHostnameForFallback) fallbackTitle = potentialHostnameForFallback;
        }
        const fallbackData = {
            url: fallbackUrl, 
            title: fallbackTitle,
            customTitle: customTitle,
            favicon: this.DEFAULT_FAVICON,
            description: '',
            addDate: (this.links[this.currentEditIndex] && this.links[this.currentEditIndex].addDate) ? this.links[this.currentEditIndex].addDate : Date.now(),
            lastModified: Date.now()
        };
        this.links[this.currentEditIndex] = fallbackData;
        this.saveLinks();
        this.expandGridIfNeeded();
        this.renderLinks();
        this.closeModal();
        showNotification('Bookmark saved (with fallback data).', 2000);
      } finally {
        saveBtn.textContent = originalSaveBtnText;
        saveBtn.disabled = false;
      }
    }

    expandGridIfNeeded() {
      const filledBoxes = Object.keys(this.links).length;
      const requiredBoxes = Math.max(5, filledBoxes + 1); // Ensure at least 5 boxes, or one more than filled
      if (this.totalBoxes < requiredBoxes) {
        const oldTotal = this.totalBoxes;
        this.totalBoxes = requiredBoxes + 4; // Add a bit of buffer
        const grid = document.getElementById('linkGrid');
        for (let i = oldTotal; i < this.totalBoxes; i++) {
          const linkBox = document.createElement('div');
          linkBox.dataset.index = i;
          linkBox.className = 'link-box';
          grid.appendChild(linkBox);
        }
      }
    }

    deleteLink(index) {
      delete this.links[index];
      // Re-index links to keep them contiguous
      const reindexedLinks = {};
      let newIndex = 0;
      Object.values(this.links).forEach(link => { // Iterate in order of current keys (which might not be contiguous after delete)
          if(link) { // Ensure link is not undefined if there were gaps
            reindexedLinks[newIndex++] = link;
          }
      });
      this.links = reindexedLinks;

      this.saveLinks();
      const filledBoxes = Object.keys(this.links).length;
      // Adjust totalBoxes: should be at least 5, or filled + 1, plus some buffer
      const newTotalBoxes = Math.max(5, filledBoxes + 1);
      if (this.totalBoxes > newTotalBoxes + 4 || this.totalBoxes < newTotalBoxes) { 
        this.totalBoxes = newTotalBoxes + (filledBoxes > 0 ? 4 : 0); // Add buffer only if there are items
        this.createGrid(); 
      }
      this.renderLinks(); 
    }

    renderLinks() {
      const linkBoxes = document.querySelectorAll('.link-box[data-index]');
      // Ensure enough boxes are created if links were added programmatically (e.g. import)
      if (Object.keys(this.links).length >= this.totalBoxes) {
          this.expandGridIfNeeded(); 
      }
      
      const currentLinkBoxes = document.querySelectorAll('.link-box[data-index]');

      currentLinkBoxes.forEach(box => {
        const index = parseInt(box.dataset.index, 10);
        const link = this.links[index];
        box.onclick = null; // Reset click handler

        if (link) {
          box.className = 'link-box'; 
          let displayedUrlText = link.url;
          if (link.url.startsWith('http://') || link.url.startsWith('https://')) {
            const hostname = this.getHostname(link.url);
            displayedUrlText = hostname || link.url; 
          } else {
            displayedUrlText = link.url; 
          }

          const titleText = link.title || 'Untitled';
          const descriptionText = link.description ? `\n\n${link.description.replace(/"/g, '&quot;')}` : '';
          const fullTitleForTooltip = `${titleText}${descriptionText}`;
          const addDate = link.addDate ? new Date(link.addDate).toLocaleDateString() : 'N/A';

          box.innerHTML = `
            <div class="link-content">
              <img src="${link.favicon || this.DEFAULT_FAVICON}" alt="Favicon" class="link-logo" onerror="this.onerror=null;this.src='${this.DEFAULT_FAVICON}'">
              <div class="link-title" title="${fullTitleForTooltip}">${titleText}</div>
              <div class="link-url" title="URL: ${link.url.replace(/"/g, '&quot;')}\nAdded: ${addDate}">${displayedUrlText}</div>
            </div>
            <button class="delete-btn">×</button>
          `;
          box.querySelector('.delete-btn').onclick = (e) => {
            e.stopPropagation();
            this.deleteLink(index);
            showNotification('Bookmark deleted.', 2000);
          };
          box.onclick = (e) => {
            if (!e.target.classList.contains('delete-btn')) {
              if (e.ctrlKey || e.metaKey) { // Ctrl/Cmd + Click to edit
                this.openModal(index);
              } else { // Normal click to open
                const urlToOpen = link.url; 
                if (urlToOpen.startsWith('http://') || urlToOpen.startsWith('https://')) {
                    window.open(urlToOpen, '_blank');
                } else if (urlToOpen) {
                    if (this.getHostname(urlToOpen) && !urlToOpen.includes('://') && !urlToOpen.startsWith('file:')) { 
                        try { window.open('https://' + urlToOpen, '_blank'); }
                        catch (openError) { showNotification(`Failed to open "https://${urlToOpen}". Not a valid web address.`, 3000); }
                    } else if (urlToOpen.includes(':') || urlToOpen.startsWith('/') || urlToOpen.startsWith('file:')) { 
                       try { window.open(urlToOpen, '_blank'); }
                       catch (openError) { showNotification(`Could not open: ${urlToOpen}. May be a local file or unsupported.`, 3000); }
                    } else { 
                       showNotification(`Not a clickable URL: ${urlToOpen}`, 3000);
                    }
                } else {
                    showNotification('This bookmark has no URL defined.', 3000);
                }
              }
            }
          };
        } else {
          box.className = 'link-box empty'; 
          box.innerHTML = `
            <img src="https://img.icons8.com/fluency/48/add-link.png" style="width:24px;height:24px;margin-bottom:6px;" alt="Add bookmark icon"/>
            <div class="add-icon">+</div>
            <div>Add Bookmark</div>
          `;
          box.onclick = () => {
            this.openModal(index);
          };
        }
      });
    }

    loadLinks() {
      try {
        const stored = localStorage.getItem('linkVaultData');
        return stored ? JSON.parse(stored) : {};
      } catch (e) {
        console.warn("localStorage not available or data corrupted. Using temporary storage.");
        if (e instanceof SyntaxError) { localStorage.removeItem('linkVaultData'); }
        // For environments where localStorage is not available (like sandboxed iframes sometimes)
        // provide a fallback to a window object. This won't persist across sessions.
        if (typeof window.linkVaultSessionStorage === 'undefined') {
            window.linkVaultSessionStorage = {};
        }
        return window.linkVaultSessionStorage;
      }
    }

    saveLinks() {
      try {
        localStorage.setItem('linkVaultData', JSON.stringify(this.links));
      } catch (e) {
        console.warn("localStorage not available. Changes will not persist across sessions.");
        window.linkVaultSessionStorage = this.links; // Save to session fallback
      }
    }

    // --- New Methods ---
    removeDuplicateLinks() {
        const seenUrls = new Set();
        const uniqueLinks = [];
        let duplicatesFound = 0;

        // Iterate in order of keys to preserve the first occurrence
        const sortedKeys = Object.keys(this.links).map(Number).sort((a, b) => a - b);

        for (const key of sortedKeys) {
            const link = this.links[key];
            if (link && link.url) {
                if (seenUrls.has(link.url)) {
                    duplicatesFound++;
                } else {
                    seenUrls.add(link.url);
                    uniqueLinks.push(link);
                }
            } else if (link) { // Link without URL, keep it
                uniqueLinks.push(link);
            }
        }

        if (duplicatesFound > 0) {
            this.links = {}; // Clear current links
            uniqueLinks.forEach((link, index) => {
                this.links[index] = link; // Re-add unique links with new contiguous indices
            });
            this.saveLinks();
            // Adjust totalBoxes if many items were removed
            const filledBoxes = Object.keys(this.links).length;
            this.totalBoxes = Math.max(5, filledBoxes + 1 + (filledBoxes > 0 ? 4 : 0) );
            this.createGrid(); // Recreate grid with correct number of boxes
            this.renderLinks();
            showNotification(`${duplicatesFound} duplicate bookmark(s) removed.`, 3000);
        } else {
            showNotification('No duplicate bookmarks found.', 2000);
        }
    }

    removeAllLinks() {
        this.links = {};
        this.totalBoxes = 5; // Reset to minimum
        this.saveLinks();
        this.createGrid(); // Recreate the empty grid
        this.renderLinks();
        showNotification('All bookmarks have been removed.', 3000);
    }

    sortLinks(criteria) {
        if (criteria === "default") {
             const linkArray = Object.entries(this.links)
                .map(([index, data]) => ({ ...data, originalIndex: parseInt(index) }))
                .sort((a, b) => a.originalIndex - b.originalIndex);
            
            this.links = {};
            linkArray.forEach((link, newIndex) => {
                delete link.originalIndex; // Clean up temporary property
                this.links[newIndex] = link;
            });
            showNotification('Sorted by original order.', 2000);

        } else {
            const linkArray = Object.values(this.links).filter(link => link); // Get all link objects

            linkArray.sort((a, b) => {
                const titleA = (a.title || '').toLowerCase();
                const titleB = (b.title || '').toLowerCase();
                const dateA = a.addDate || 0;
                const dateB = b.addDate || 0;

                switch (criteria) {
                    case 'name_asc':
                        return titleA.localeCompare(titleB);
                    case 'name_desc':
                        return titleB.localeCompare(titleA);
                    case 'date_asc':
                        return dateA - dateB;
                    case 'date_desc':
                        return dateB - dateA;
                    default:
                        return 0;
                }
            });

            this.links = {}; // Clear current links
            linkArray.forEach((link, index) => {
                this.links[index] = link; // Re-add sorted links with new contiguous indices
            });
            showNotification(`Sorted by ${criteria.replace('_', ' ')}.`, 2000);
        }
        
        this.saveLinks();
        this.renderLinks(); // Re-render the sorted links
    }

  } // End of LinkManager Class

  document.addEventListener('DOMContentLoaded', () => {
    globalLinkManager = new LinkManager();

    // Initialize SortableJS
    new Sortable(document.getElementById('linkGrid'), {
      animation: 150,
      draggable: ".link-box:not(.empty)", // Only actual links are draggable
      filter: ".delete-btn", // Clicking delete button won't start drag
      preventOnFilter: true, // Required for filter to work
      onEnd: (evt) => {
        let orderedLinkItems = [];
        const currentKeys = Object.keys(globalLinkManager.links).map(Number).sort((a,b) => a-b);
        currentKeys.forEach(key => {
            if(globalLinkManager.links[key]) { // Ensure link exists at this key
                orderedLinkItems.push(globalLinkManager.links[key]);
            }
        });
        
        if (evt.oldDraggableIndex < orderedLinkItems.length && evt.newDraggableIndex < orderedLinkItems.length) {
            const [movedItem] = orderedLinkItems.splice(evt.oldDraggableIndex, 1);
            orderedLinkItems.splice(evt.newDraggableIndex, 0, movedItem);

            const reorderedLinks = {};
            orderedLinkItems.forEach((link, index) => {
                reorderedLinks[index] = link;
            });
            
            globalLinkManager.links = reorderedLinks;
            globalLinkManager.saveLinks();

            // === FIX START ===
            // Re-assign data-index to all boxes based on their new DOM order.
            // This ensures renderLinks() uses the correct index for each box's new position.
            const gridElement = document.getElementById('linkGrid');
            Array.from(gridElement.children).forEach((boxElement, newIndex) => {
                if (boxElement.classList.contains('link-box')) { // Ensure it's a link-box
                    boxElement.dataset.index = newIndex;
                }
            });
            // === FIX END ===
            
            globalLinkManager.renderLinks(); 
            showNotification('Order saved!', 1500);
        } else {
            console.error("SortableJS drag indices out of bounds. Aborting reorder.", {
                oldDraggableIndex: evt.oldDraggableIndex,
                newDraggableIndex: evt.newDraggableIndex,
                numberOfLinks: orderedLinkItems.length
            });
            globalLinkManager.renderLinks(); // Re-render to fix any visual glitch
        }
      }
    });

    // Dark Mode Toggle
    const darkToggle = document.getElementById('darkModeToggle');
    function applyDarkModePreference() {
        const storedDarkMode = localStorage.getItem('darkMode');
        if (storedDarkMode === 'true') {
            document.body.classList.add('dark');
            if(darkToggle) darkToggle.checked = true;
        } else if (storedDarkMode === 'false') { // Explicitly false
            document.body.classList.remove('dark');
            if(darkToggle) darkToggle.checked = false;
        } else { // Not set or invalid value, default to light
            document.body.classList.remove('dark'); 
            if(darkToggle) darkToggle.checked = false;
        }
    }
    applyDarkModePreference(); // Apply on load

    if (darkToggle) {
        darkToggle.addEventListener('change', () => {
            if (darkToggle.checked) {
                document.body.classList.add('dark');
                localStorage.setItem('darkMode', 'true');
            } else {
                document.body.classList.remove('dark');
                localStorage.setItem('darkMode', 'false');
            }
        });
    }

    // Export JSON
    document.getElementById('exportBtn').addEventListener('click', () => {
      if (!globalLinkManager) return;
      // Export only actual link data, not the empty placeholders in the object
      const linksToExport = Object.values(globalLinkManager.links || {}).filter(link => link !== undefined && link !== null);
      if (linksToExport.length === 0) {
        showNotification("No bookmarks to export.", 2000);
        return;
      }
      const blob = new Blob([JSON.stringify(linksToExport, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'linkvault_export.json';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      showNotification("Bookmarks exported as JSON.", 2000);
    });

    // Import JSON
    document.getElementById('importBtn').addEventListener('click', () => {
      document.getElementById('importInput').click(); // Trigger file input
    });
    document.getElementById('importInput').addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const text = await file.text();
      e.target.value = null; // Reset file input
      try {
        const importedLinksArray = JSON.parse(text);
        if (!Array.isArray(importedLinksArray)) {
            showNotification('Invalid JSON. Expected an array.', 3000); return;
        }
        let nextIndex = 0;
        const existingIndices = Object.keys(globalLinkManager.links).map(Number);
        if (existingIndices.length > 0) {
            // Find the maximum existing index and add 1, or start from 0 if no links.
            // This ensures imported links are appended.
            nextIndex = Math.max(-1, ...existingIndices) + 1;
        }
        
        let importedCount = 0;
        importedLinksArray.forEach((link) => {
          // Basic validation for imported link structure
          if (link && typeof link.url === 'string' && (typeof link.title === 'string' || typeof link.customTitle === 'string')) {
            globalLinkManager.links[nextIndex++] = {
                url: link.url, 
                title: link.title || link.customTitle || globalLinkManager.getHostname(link.url) || "Untitled",
                customTitle: link.customTitle || link.title, // Prefer customTitle if present
                favicon: link.favicon || globalLinkManager.DEFAULT_FAVICON,
                description: link.description || "",
                addDate: link.addDate || Date.now(), // Ensure addDate
                lastModified: link.lastModified || Date.now()
            };
            importedCount++;
          } else { console.warn("Skipping invalid link object during JSON import:", link); }
        });

        if (importedCount > 0) {
            globalLinkManager.totalBoxes = Math.max(5, Object.keys(globalLinkManager.links).length + 1 + 4);
            globalLinkManager.saveLinks();
            globalLinkManager.createGrid(); // Recreate grid if totalBoxes changed
            globalLinkManager.renderLinks();
            showNotification(`${importedCount} bookmarks imported from JSON.`, 2500);
        } else {
            showNotification("No valid bookmarks found in JSON file.", 2500);
        }
      } catch (err) { 
        showNotification('Error importing JSON: ' + err.message, 4000); 
        console.error("JSON Import Error:", err); 
      }
    });

    // Search Functionality
    document.getElementById('searchInput').addEventListener('input', (e) => {
      const query = e.target.value.toLowerCase().trim();
      document.querySelectorAll('.link-box').forEach(box => {
        if (box.classList.contains('empty')) { 
            // Empty boxes should generally remain visible unless the grid is full and filtering hides everything else
            // For simplicity, let's always show empty boxes if search is active, or hide if not relevant.
            // Let's hide empty boxes during search to reduce clutter.
            box.style.display = query ? 'none' : 'flex'; 
            return; 
        }
        const index = parseInt(box.dataset.index, 10);
        const linkData = globalLinkManager.links[index];
        if (linkData) {
            const title = (linkData.title || '').toLowerCase();
            const url = (linkData.url || '').toLowerCase();
            const description = (linkData.description || '').toLowerCase();
            const hostname = (globalLinkManager.getHostname(linkData.url) || '').toLowerCase();
            
            box.style.display = (title.includes(query) || url.includes(query) || description.includes(query) || hostname.includes(query)) ? 'flex' : 'none';
        } else { 
            box.style.display = query ? 'none' : 'flex'; // Show if not searching, hide if searching
        }
      });
    });

    // Export HTML
    document.getElementById('exportHtmlBtn').addEventListener('click', () => {
      if (!globalLinkManager) return;
      const linksToExport = Object.values(globalLinkManager.links || {}).filter(link => link);
      if (linksToExport.length === 0) {
        showNotification("No bookmarks to export.", 2000);
        return;
      }
      let htmlContent = `<!DOCTYPE NETSCAPE-Bookmark-file-1>
        <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8">
        <TITLE>Bookmarks</TITLE>
        <H1>LinkVault Bookmarks</H1>
        <DL><p>\n`;
      // Use current timestamp for export if addDate is missing, though it should always be present now
      const nowEpoch = Math.floor(Date.now() / 1000); 
      linksToExport.forEach(link => {
        const escapedTitle = (link.title || link.customTitle || link.url || 'Untitled').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
        const escapedUrl = (link.url || '').replace(/&/g, '&amp;').replace(/"/g, '&quot;');
        // Use addDate (converted to epoch seconds) if available, otherwise current time
        const addDateEpoch = link.addDate ? Math.floor(new Date(link.addDate).getTime() / 1000) : nowEpoch;
        const lastModifiedEpoch = link.lastModified ? Math.floor(new Date(link.lastModified).getTime() / 1000) : addDateEpoch;
        const favicon = (link.favicon && link.favicon !== globalLinkManager.DEFAULT_FAVICON && (link.favicon.startsWith('http') || link.favicon.startsWith('data:'))) ? link.favicon : '';
        
        htmlContent += `    <DT><A HREF="${escapedUrl}" ADD_DATE="${addDateEpoch}" LAST_MODIFIED="${lastModifiedEpoch}" ${favicon ? `ICON="${favicon.replace(/"/g, '&quot;')}"` : ''}>${escapedTitle}</A>\n`;
        if (link.description) {
            htmlContent += `        <DD>${link.description.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')}\n`;
        }
      });
      htmlContent += `</DL><p>`;
      const blob = new Blob([htmlContent], { type: 'text/html' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'linkvault_bookmarks.html';
      document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
      showNotification("Bookmarks exported as HTML.", 2000);
    });

    // Import HTML
    document.getElementById('importHtmlBtn').addEventListener('click', () => {
      document.getElementById('importHtmlInput').click();
    });
    document.getElementById('importHtmlInput').addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const text = await file.text();
      e.target.value = null; // Reset file input
      const parser = new DOMParser();
      const doc = parser.parseFromString(text, "text/html");
      const anchors = doc.querySelectorAll("dt > a, a"); // More robust selector for A tags within DT or just A tags
      
      let nextIndex = 0;
      const existingIndices = Object.keys(globalLinkManager.links).map(Number);
      if (existingIndices.length > 0) nextIndex = Math.max(-1, ...existingIndices) + 1;
      
      let importedCount = 0;
      for (const a of anchors) {
        const href = a.getAttribute("href");
        let title = a.textContent.trim();
        if (!title && href) title = globalLinkManager.getHostname(href) || href; // Fallback title
        
        const addDateAttr = a.getAttribute("add_date");
        const lastModifiedAttr = a.getAttribute("last_modified");
        const iconAttr = a.getAttribute("icon");
        
        // Check if this <a> tag is directly inside a <DT> which is standard for bookmarks
        // This helps filter out other links in the HTML file if any.
        // However, some exports might just be a list of <a> tags.
        // For now, we accept any <a> with an href.
        if (href && (href.startsWith("http") || href.startsWith("ftp") || href.startsWith("file") || href.startsWith("javascript:"))) {
          let favicon = globalLinkManager.DEFAULT_FAVICON;
          if (iconAttr && (iconAttr.startsWith('http') || iconAttr.startsWith('data:'))) {
            favicon = iconAttr;
          } else if (href.startsWith("http")) { // Only try Google Favicons for http/https
            const domain = globalLinkManager.getHostname(href);
            if (domain) favicon = `https://www.google.com/s2/favicons?domain=${domain}&sz=64`;
          }

          // Description is often in a <DD> tag immediately following the <DT> that contains the <A>
          let description = "";
          if (a.parentElement && a.parentElement.tagName === 'DT') {
            const nextSibling = a.parentElement.nextElementSibling;
            if (nextSibling && nextSibling.tagName === 'DD') {
                description = nextSibling.textContent.trim();
            }
          }
          
          globalLinkManager.links[nextIndex++] = {
            url: href, 
            title: title, 
            customTitle: title, // Set customTitle same as title from import
            favicon: favicon,
            description: description,
            addDate: addDateAttr ? parseInt(addDateAttr, 10) * 1000 : Date.now(), // Convert epoch seconds to ms
            lastModified: lastModifiedAttr ? parseInt(lastModifiedAttr, 10) * 1000 : (addDateAttr ? parseInt(addDateAttr, 10) * 1000 : Date.now())
          };
          importedCount++;
        }
      }
      if (importedCount > 0) {
        globalLinkManager.totalBoxes = Math.max(5, Object.keys(globalLinkManager.links).length + 1 + 4);
        globalLinkManager.saveLinks(); 
        globalLinkManager.createGrid(); 
        globalLinkManager.renderLinks();
        showNotification(`Imported ${importedCount} bookmarks from HTML.`, 2500);
      } else { 
        showNotification("No valid bookmarks found in the HTML file.", 2500); 
      }
    });

  }); // End of DOMContentLoaded
</script>
</body>
</html>